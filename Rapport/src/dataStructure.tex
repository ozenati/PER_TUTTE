In the implementation of our sulution we have defined our own data structure on which we excute the Tutte's algorithm. We have implemented some mechanisms to convert a tulip format graph to our own graph structure and also to get informations from our structure inserted in a tulip format graph. In other words our structure is a temporary structure for storing informations about nodes in order to execute the Tutte's algorithm.

\subsection{Aim}
As a format tulip contains a lot of informations so it costs a lot to manipulate them and so far away we do not need all the informations about a given tulip graph. To point out we especially do not need all the properties about nodes to conduct the Tutte's algorithm.For intance, for a given node we just want to know if it is fixed for a fixed node's position nevers changes during the tutte's algorithme. In addition of that, as we are looking for performance, we need a light and adapted structure to the principe of Tutte's algorithm. Below are some of criterias which make us thought we need a new data structure.
\begin{enumerate}
\item The fact that a given node is fixed or not is indicated firsly by a mobility property. However there is anover property incating nodes wich are part of graph contouring and these nodes need to be fixed too. So to deal with the fact that a given node is fixed or not we need to manipulate two properties that cost a lot.

\item The data structure in a tulip graph ...

\end{enumerate}  

\subsection{First implementation}
In order to avoid memory leak and implemente easily the Tutte's algorithme, we merely stock in our sttructure only the informations needed to run the algorithm. We implemented our structure so that one can easily access the neighbourhood of a given node for it is very crucial in a Tutte'algorithm. To do this we define a class that contains diferent informations needed on a given node (the attibuts) and all the operations we need to run on a node (the methods).

\begin{lstlisting}
class MyNode {
 private:
  node n;
  bool mobile;
  Coord coord;  
  vector<MyNode *> voisin;

 public:
  MyNode();
  MyNode(const node n, const Coord coord);
  MyNode(const node n, const bool mob, const Coord coord);
  ~MyNode();
  
  const node getNode() const;
  bool getMobile() const;
  void setMobile(const bool b);
  const Coord getCoord() const;
  void setCoord(const Coord &);
  vector<MyNode *> * getVoisin();
  vector<MyNode *> getVoisin() const;
};
\end{lstlisting}

\subsubsection{The vertex's attributs needed}


\subsubsection{The operations on a vertex}

\subsection{Enhanced implementation}
